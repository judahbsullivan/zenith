# Zenith Framework — Build Checklist


## This is a general checklist generated by chatgpt( it could change by need)

> One step at a time. This checklist is ordered. Do **not** skip ahead. Lets make sure we test all. 

---

## Phase 0 — Ground Rules (Lock These In)

* [ ] Zenith is **HTML-first**
* [ ] `.zenith` files are valid HTML
* [ ] `<script>` and `<style>` are optional
* [ ] No `use client` / `client-only`
* [ ] Client vs server is inferred via static analysis
* [ ] Navigation lifecycle is a first-class runtime primitive
* [ ] Layouts own the document, pages own views

---

## Phase 1 — Compiler Foundation (START HERE)

### 1. Define the Compiler Contract

* [ ] Create `packages/compiler/spec.ts`
* [ ] Define `ZenithFile` shape
* [ ] Include:

  * DOM AST
  * Script block (optional)
  * Style block (optional)
  * `ownsDocument: boolean`

---

### 2. HTML Parsing

* [ ] Choose HTML parser (`parse5`, `linkedom`, or `@astrojs/compiler`)
* [ ] Implement `parseZenith(source: string)`
* [ ] Extract:

  * DOM AST
  * `<script>` contents
  * `<style>` contents
* [ ] Preserve original node order

---

### 3. Document Ownership Detection

* [ ] Scan DOM for `<html>` node
* [ ] Set `ownsDocument = true | false`
* [ ] No configuration flags allowed

---

## Phase 2 — Layout System (Compile-Time)

### 4. Layout Resolution

* [ ] Support `layout.zenith` files
* [ ] Support nested layouts
* [ ] Determine active layout per page

---

### 5. `<slot />` Composition

* [ ] Implement compile-time `<slot />` replacement
* [ ] Inject page DOM into layout DOM
* [ ] If page owns document → skip layout

---

### 6. Head Handling (Static)

* [ ] Allow `<head>` in layout or page
* [ ] Merge head nodes during composition
* [ ] Preserve order

---

## Phase 3 — Static Analysis (Zenith’s Killer Feature)

### 7. DOM Binding Detection

* [ ] Detect `{{ expression }}` text bindings
* [ ] Detect event bindings (`@click`, `@input`, etc.)
* [ ] Detect dynamic attributes (`:class`, `:style`, etc.)

---

### 8. Script Analysis

* [ ] Parse `<script>` into AST
* [ ] Identify:

  * `const` (static)
  * `let` (reactive)
  * function declarations
* [ ] Track usage from DOM bindings

---

### 9. Runtime Requirements Decision

* [ ] Decide:

  * needs client runtime
  * needs reactivity
  * needs VDOM diffing
* [ ] Zero JS if no bindings or events

---

## Phase 4 — Code Generation

### 10. Render Function Generation

* [ ] Generate JS render functions from DOM AST
* [ ] Output `createElement(...)` calls
* [ ] No diffing yet

---

### 11. Style Handling

* [ ] Scope styles per component
* [ ] Generate hashed class names
* [ ] Inject styles once

---

## Phase 5 — Runtime Core

### 12. Navigation Runtime

* [ ] History API wrapper
* [ ] `beforeNavigate` hooks
* [ ] `afterNavigate` hooks
* [ ] Popstate handling

---

### 13. Router

* [ ] Map URL → compiled component
* [ ] Layout persistence across routes

---

### 14. Render Scheduler

* [ ] Subscribe to navigation changes
* [ ] Trigger re-render only when needed

---

## Phase 6 — VDOM & Reactivity

### 15. Minimal VDOM

* [ ] Define `VNode`
* [ ] Implement mount renderer

---

### 16. Diffing (Optional but Planned)

* [ ] Implement keyed diff
* [ ] Skip diffing for static trees

---

### 17. Reactivity System

* [ ] Track `let` bindings
* [ ] Trigger re-render on mutation
* [ ] Fine-grained updates (no global rerender)

---

## Phase 7 — Hooks

### 18. Hook Dispatcher

* [ ] Implement `useState`
* [ ] Implement `useEffect`
* [ ] Hook lifecycle tied to component instance

---

## Phase 8 — Advanced Navigation

### 19. Layout Persistence

* [ ] Preserve layout instances
* [ ] Destroy only when layout changes

---

### 20. Page Transitions

* [ ] Expose navigation lifecycle to components
* [ ] Allow animations before/after navigation

---

## Phase 9 — SSR & Streaming (Later)

* [ ] Server-side render HTML
* [ ] Stream layout first
* [ ] Stream page content
* [ ] Attach minimal client runtime

---

## Phase 10 — Tooling

* [ ] `zenith build`
* [ ] `zenith dev`
* [ ] File watcher
* [ ] HMR (optional)

---

## Final Rule

> **If a feature cannot be inferred from HTML usage, it does not belong in Zenith.**

---

✅ Follow this checklist in order.
❌ Do not jump phases.

Next step when ready: **Phase 1, Step 1 — Compiler Contract**.
